import math
import re
from typing import Dict, List, Optional, Set

from gen_ast import *


class OdinGenerator:
    def __init__(self, module: ApiModule):
        self.module = module
        self.output = []
        self.name_map: Dict[str, str] = {}
        self.handle_types: Set[str] = set()
        self.struct_types: Set[str] = set()
        self.primitives = {
            "u8": "u8",
            "u16": "u16",
            "u32": "u32",
            "u64": "u64",
            "i8": "i8",
            "i16": "i16",
            "i32": "i32",
            "i64": "i64",
            "f32": "f32",
            "f64": "f64",
            "bool": "bool",
            "usize": "uint",
            "isize": "int",
            "c_char": "u8",
            "c_void": "c.void",
        }
        self.preprocess()

    def strip_rfx(self, name: str) -> str:
        return re.sub(r"^(rfx|RFX|Rfx)_?", "", name)

    def to_snake_case(self, name: str) -> str:
        name = self.strip_rfx(name)
        s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
        return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()

    def to_pascal_case(self, name: str) -> str:
        name = self.strip_rfx(name)
        return "".join(word.title() for word in name.split("_"))

    def to_screaming_snake_case(self, name: str) -> str:
        name = self.strip_rfx(name)
        s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
        return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).upper()

    def preprocess(self):
        for s_name, s in self.module.structs_map.items():
            if s.is_opaque:
                self.handle_types.add(s_name)
            else:
                self.struct_types.add(s_name)
        for td in self.module.typedefs:
            if td.target_type.is_pointer and td.target_type.name not in self.primitives:
                self.handle_types.add(td.name)

        # Handles
        for h in sorted(self.handle_types):
            safe = self.strip_rfx(h)
            if safe.endswith("Impl"):
                safe = safe[:-4]
            self.name_map[h] = safe
        # Structs
        for s in sorted(self.struct_types):
            if s not in self.name_map:
                self.name_map[s] = self.strip_rfx(s)
        # Enums
        for e in self.module.enums:
            if not e.is_anonymous and e.name:
                self.name_map[e.name] = self.strip_rfx(e.name)
        # Typedefs
        for td in self.module.typedefs:
            if td.name not in self.name_map:
                self.name_map[td.name] = self.strip_rfx(td.name)

    def get_odin_type(self, t: TypeInfo) -> str:
        if t.array_size is not None:
            inner = self.get_odin_type(TypeInfo(t.name))
            if t.array_size_2d:
                return f"[{t.array_size_2d}][{t.array_size}]{inner}"
            return f"[{t.array_size}]{inner}"
        base = t.name
        if t.is_pointer:
            if base in ["char", "c_char"]:
                return "cstring"
            if base in ["void", "c_void"]:
                return "rawptr"
            return f"^{self.get_odin_type(TypeInfo(base, is_const=t.is_const))}"

        if base in self.primitives:
            return self.primitives[base]
        if base in self.name_map:
            return self.name_map[base]
        if "uint" in base:
            return "u32"
        if "int" in base:
            return "i32"
        if "bool" in base:
            return "bool"
        return "rawptr" if "void" in base else base

    def emit(self, s="", i=0):
        self.output.append("\t" * i + s)

    def get_enum_prefix(self, values: List[EnumValue]) -> str:
        if not values:
            return ""
        p = values[0].name
        for v in values[1:]:
            while not v.name.startswith(p) and p:
                p = p[:-1]
        if "_" in p:
            p = p[: p.rfind("_") + 1]
        return p

    def generate(self) -> str:
        self.emit(
            "// This file is @generated by Rafx's bindings generator; DO NOT MODIFY, open an issue in https://github.com/zeozeozeo/rafx/issues instead"
        )
        self.emit("package rafx")
        self.emit()
        self.emit('import "core:c"')
        self.emit()
        self.emit("when ODIN_OS == .Windows {")
        self.emit('\tforeign import lib { "rafx.lib" }')
        self.emit("} else when ODIN_OS == .Linux {")
        self.emit('\tforeign import lib { "rafx.a" }')
        self.emit("} else {")
        self.emit('\tforeign import lib { "rafx.a" }')
        self.emit("}")
        self.emit()

        # Enums
        self.emit("// Enums")
        for e in self.module.enums:
            if e.is_anonymous:
                continue
            name = self.name_map[e.name]
            prefix = self.get_enum_prefix(e.values)

            bit_type = "u32"
            if "8" in e.underlying_type:
                bit_type = "u8"
            elif "16" in e.underlying_type:
                bit_type = "u16"

            if e.is_bitflags:
                flag_name = name.replace("Flags", "Flag")
                if flag_name == name:
                    flag_name = name + "Bit"

                self.emit(f"{flag_name} :: enum {bit_type} {{")
                seen = set()
                flag_values = []
                for v in e.values:
                    if v.value == 0:
                        continue
                    if (v.value & (v.value - 1)) != 0:
                        continue

                    idx = int(math.log2(v.value))
                    vname = (
                        v.name[len(prefix) :] if v.name.startswith(prefix) else v.name
                    )
                    vname = self.to_pascal_case(vname)
                    if vname[0].isdigit():
                        vname = "V" + vname

                    if idx in seen:
                        self.emit(f"// {vname} = {idx}, // Duplicate", 1)
                    else:
                        seen.add(idx)
                        flag_values.append(vname)
                        self.emit(f"{vname} = {idx},", 1)
                self.emit("}")
                self.emit(f"{name} :: bit_set[{flag_name}; {bit_type}]")
                self.emit()
            else:
                underlying = "u32"
                if "int" in e.underlying_type and "unsigned" not in e.underlying_type:
                    underlying = "i32"
                if "u8" in e.underlying_type:
                    underlying = "u8"

                self.emit(f"{name} :: enum {underlying} {{")
                seen = set()
                for v in e.values:
                    vname = (
                        v.name[len(prefix) :] if v.name.startswith(prefix) else v.name
                    )
                    vname = self.to_pascal_case(vname)
                    if not vname:
                        vname = "None"
                    if vname[0].isdigit():
                        vname = "V" + vname
                    if vname in ["None", "In", "Out"]:
                        vname += "_"

                    if v.value in seen:
                        self.emit(f"// {vname} = {v.value}, // Duplicate", 1)
                    else:
                        seen.add(v.value)
                        self.emit(f"{vname} = {v.value},", 1)
                self.emit("}")
                self.emit()

        # Handles
        self.emit("// Handles")
        printed = set()
        for h in sorted(self.handle_types):
            n = self.name_map[h]
            if n not in printed:
                printed.add(n)
                self.emit(f"{n} :: distinct rawptr")
        self.emit()

        # Structs
        self.emit("// Structs")
        for s_name in sorted(self.struct_types):
            s = self.module.structs_map[s_name]
            name = self.name_map[s_name]
            kind = "struct #raw_union" if s.is_union else "struct"
            self.emit(f"{name} :: {kind} {{")
            for f in s.fields:
                fname = self.to_snake_case(f.name)
                if fname in ["context", "in", "map", "proc", "type", "defer", "or"]:
                    fname += "_"
                self.emit(f"{fname}: {self.get_odin_type(f.type_info)},", 1)
            self.emit("}")
            self.emit()

        # Functions
        self.emit("// Functions")
        self.emit('@(default_calling_convention="c")')
        self.emit("foreign lib {")
        for f in self.module.functions:
            fname = self.to_snake_case(f.name)
            args = []
            for p in f.params:
                pname = self.to_snake_case(p.name)
                if pname in ["context", "in", "map", "proc", "type", "defer"]:
                    pname += "_"
                args.append(f"{pname}: {self.get_odin_type(p.type_info)}")

            ret = ""
            if f.ret_type.name not in ["void", "c_void"] or f.ret_type.is_pointer:
                ret = f" -> {self.get_odin_type(f.ret_type)}"

            if fname != f.name:
                self.emit(f'@(link_name="{f.name}")', 1)
            self.emit(f"{fname} :: proc({', '.join(args)}){ret} ---", 1)
        self.emit("}")

        return "\n".join(self.output)
