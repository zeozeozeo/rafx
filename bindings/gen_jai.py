import math
import re
from typing import Dict, List, Set

from gen_ast import ApiModule, EnumValue, TypeInfo


class JaiGenerator:
    def __init__(self, module: ApiModule):
        self.module = module
        self.output = []
        self.name_map: Dict[str, str] = {}
        self.handle_types: Set[str] = set()
        self.struct_types: Set[str] = set()
        self.primitives = {
            "u8": "u8",
            "u16": "u16",
            "u32": "u32",
            "u64": "u64",
            "i8": "s8",
            "i16": "s16",
            "i32": "s32",
            "i64": "s64",
            "f32": "float32",
            "f64": "float64",
            "bool": "bool",
            "usize": "u64",
            "isize": "s64",
            "c_char": "u8",
            "c_void": "void",
        }
        self.preprocess()

    def strip_rfx(self, name: str) -> str:
        return re.sub(r"^(rfx|RFX|Rfx)_?", "", name)

    def to_snake_case(self, name: str) -> str:
        name = self.strip_rfx(name)
        s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
        return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()

    def to_pascal_case(self, name: str) -> str:
        name = self.strip_rfx(name)
        return "".join(word.title() for word in name.split("_"))

    def preprocess(self):
        for s_name, s in self.module.structs_map.items():
            if s.is_opaque:
                self.handle_types.add(s_name)
            else:
                self.struct_types.add(s_name)

        for td in self.module.typedefs:
            if td.target_type.is_pointer and td.target_type.name not in self.primitives:
                self.handle_types.add(td.name)

        for h in sorted(self.handle_types):
            safe = self.strip_rfx(h)
            if safe.endswith("Impl"):
                safe = safe[:-4]
            self.name_map[h] = safe

        for s in sorted(self.struct_types):
            if s not in self.name_map:
                self.name_map[s] = self.strip_rfx(s)

        for e in self.module.enums:
            if not e.is_anonymous and e.name:
                self.name_map[e.name] = self.strip_rfx(e.name)

        for td in self.module.typedefs:
            if td.name not in self.name_map:
                self.name_map[td.name] = self.strip_rfx(td.name)

    def get_jai_type(self, t: TypeInfo) -> str:
        if t.array_size is not None:
            inner = self.get_jai_type(TypeInfo(t.name))
            if t.array_size_2d:
                return f"[{t.array_size_2d}][{t.array_size}]{inner}"
            return f"[{t.array_size}]{inner}"

        base = t.name
        if t.is_pointer:
            if base in ["char", "c_char"]:
                return "*u8"
            if base in ["void", "c_void"]:
                return "*void"
            return f"*{self.get_jai_type(TypeInfo(base, is_const=t.is_const))}"

        if base in self.primitives:
            return self.primitives[base]
        if base in self.name_map:
            return self.name_map[base]

        if "uint" in base:
            return "u32"
        if "int" in base:
            return "s32"
        return "*void" if "void" in base else base

    def emit(self, s="", indent=0):
        self.output.append("    " * indent + s)

    def get_enum_prefix(self, values: List[EnumValue]) -> str:
        if not values:
            return ""
        p = values[0].name
        for v in values[1:]:
            while not v.name.startswith(p) and p:
                p = p[:-1]
        if "_" in p:
            p = p[: p.rfind("_") + 1]
        return p

    def generate(self) -> str:
        self.emit(
            "// This file is @generated by Rafx's bindings generator; DO NOT MODIFY, open an issue in https://github.com/zeozeozeo/rafx/issues instead"
        )
        self.emit()

        self.emit("#if OS == .WINDOWS {")
        self.emit('    librafx :: #library "rafx";', 1)
        self.emit("} else {")
        self.emit('    librafx :: #library "rafx";', 1)
        self.emit("}")
        self.emit()

        # Enums
        self.emit("// Enums")
        for e in self.module.enums:
            if e.is_anonymous:
                continue
            name = self.name_map[e.name]
            prefix = self.get_enum_prefix(e.values)
            underlying = "s32"
            if "8" in e.underlying_type:
                underlying = "u8"
            elif "16" in e.underlying_type:
                underlying = "u16"

            enum_kind = "enum_flags" if e.is_bitflags else "enum"
            self.emit(f"{name} :: {enum_kind} {underlying} {{")
            seen_values = set()
            for v in e.values:
                vname = v.name[len(prefix) :] if v.name.startswith(prefix) else v.name
                vname = self.to_pascal_case(vname)
                if vname and vname[0].isdigit():
                    vname = "_" + vname
                if not vname:
                    vname = "None"

                if not e.is_bitflags:
                    if v.value in seen_values:
                        self.emit(f"// {vname} :: {v.value}; // Duplicate", 1)
                        continue
                    seen_values.add(v.value)
                self.emit(f"{vname} :: {v.value};", 1)
            self.emit("}")
            self.emit()

        self.emit("// Handles")
        unique_jai_handles = sorted(
            list(set(self.name_map[h] for h in self.handle_types if h in self.name_map))
        )
        for n in unique_jai_handles:
            self.emit(f"{n}_Impl :: struct {{}}")
            self.emit(f"{n} :: *{n}_Impl;")
        self.emit()

        # Structs
        self.emit("// Structs")
        for s_name in sorted(self.struct_types):
            s = self.module.structs_map[s_name]
            name = self.name_map[s_name]
            kind = "union" if s.is_union else "struct"

            self.emit(f"{name} :: {kind} {{")
            for f in s.fields:
                fname = self.to_snake_case(f.name)
                if fname in [
                    "context",
                    "in",
                    "map",
                    "if",
                    "else",
                    "for",
                    "while",
                    "return",
                    "struct",
                    "enum",
                    "union",
                    "type",
                ]:
                    fname += "_"
                ftype = self.get_jai_type(f.type_info)
                self.emit(f"{fname}: {ftype};", 1)
            self.emit("}")
            self.emit()

        # Functions
        self.emit("// Functions")
        for f in self.module.functions:
            fname = self.to_snake_case(f.name)
            args = []
            for p in f.params:
                pname = self.to_snake_case(p.name)
                if pname in [
                    "context",
                    "in",
                    "map",
                    "if",
                    "else",
                    "for",
                    "while",
                    "return",
                ]:
                    pname += "_"
                ptype = self.get_jai_type(p.type_info)
                args.append(f"{pname}: {ptype}")

            args_str = ", ".join(args)
            ret_type = ""
            if f.ret_type.name not in ["void", "c_void"] or f.ret_type.is_pointer:
                ret_type = f" -> {self.get_jai_type(f.ret_type)}"

            self.emit(f'{fname} :: ({args_str}){ret_type} #foreign librafx "{f.name}";')

        return "\n".join(self.output)
