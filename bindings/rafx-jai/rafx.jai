// This file is @generated by Rafx's bindings generator; DO NOT MODIFY, open an issue in https://github.com/zeozeozeo/rafx/issues instead

#if OS == .WINDOWS {
        librafx :: #library "rafx";
} else {
        librafx :: #library "rafx";
}

// Enums
Filter :: enum s32 {
    Nearest :: 0;
    Linear :: 1;
}

AddressMode :: enum s32 {
    Repeat :: 0;
    Clamp :: 1;
    Mirror :: 2;
}

Topology :: enum s32 {
    TriangleList :: 0;
    TriangleStrip :: 1;
    PointList :: 2;
    LineList :: 3;
    LineStrip :: 4;
    LineListWithAdjacency :: 5;
    LineStripWithAdjacency :: 6;
    TriangleListWithAdjacency :: 7;
    TriangleStripWithAdjacency :: 8;
    PatchList :: 9;
}

BufferUsageFlags :: enum_flags s32 {
    ShaderResource :: 1;
    ShaderResourceStorage :: 2;
    VertexBuffer :: 4;
    IndexBuffer :: 8;
    ConstantBuffer :: 16;
    ArgumentBuffer :: 32;
    ScratchBuffer :: 64;
    ShaderBindingTable :: 128;
    AccelerationStructureBuildInput :: 256;
    MicromapBuildInput :: 512;
    TransferSrc :: 1024;
    TransferDst :: 2048;
}

ResourceState :: enum s32 {
    Undefined :: 0;
    Present :: 1;
    CopySrc :: 2;
    CopyDst :: 3;
    VertexBuffer :: 4;
    IndexBuffer :: 5;
    IndirectArgument :: 6;
    ShaderRead :: 7;
    ShaderWrite :: 8;
    RenderTarget :: 9;
    DepthRead :: 10;
    DepthWrite :: 11;
    ScratchBuffer :: 12;
    ResolveSrc :: 13;
    ResolveDst :: 14;
}

MemoryType :: enum s32 {
    GpuOnly :: 0;
    CpuToGpu :: 1;
    GpuToCpu :: 2;
}

Format :: enum s32 {
    Unknown :: 0;
    Rgba8Unorm :: 1;
    Rgba8Srgb :: 2;
    Bgra8Unorm :: 3;
    Bgra8Srgb :: 4;
    R8Uint :: 5;
    R8Sint :: 6;
    Rg8Uint :: 7;
    Rg8Sint :: 8;
    Rgba8Uint :: 9;
    Rgba8Sint :: 10;
    R16Uint :: 11;
    R16Sint :: 12;
    R16Unorm :: 13;
    R16Snorm :: 14;
    Rg16Uint :: 15;
    Rg16Sint :: 16;
    Rg16Unorm :: 17;
    Rg16Snorm :: 18;
    Rgba16Uint :: 19;
    Rgba16Sint :: 20;
    Rgba16Unorm :: 21;
    Rgba16Snorm :: 22;
    R32Uint :: 23;
    R32Sint :: 24;
    Rg32Uint :: 25;
    Rg32Sint :: 26;
    Rgb32Uint :: 27;
    Rgb32Sint :: 28;
    Rgba32Uint :: 29;
    Rgba32Sint :: 30;
    R10G10B10A2Unorm :: 31;
    R10G10B10A2Uint :: 32;
    R11G11B10Ufloat :: 33;
    R9G9B9E5Ufloat :: 34;
    Bc1RgbaUnorm :: 35;
    Bc1RgbaSrgb :: 36;
    Bc2RgbaUnorm :: 37;
    Bc2RgbaSrgb :: 38;
    Bc3RgbaUnorm :: 39;
    Bc3RgbaSrgb :: 40;
    Bc4RUnorm :: 41;
    Bc4RSnorm :: 42;
    Bc5RgUnorm :: 43;
    Bc5RgSnorm :: 44;
    Bc6HRgbUfloat :: 45;
    Bc6HRgbSfloat :: 46;
    Bc7RgbaUnorm :: 47;
    Bc7RgbaSrgb :: 48;
    D16Unorm :: 49;
    D24UnormS8Uint :: 50;
    D32Float :: 51;
    D32FloatS8UintX24 :: 52;
    R32Float :: 53;
    Rg32Float :: 54;
    Rgb32Float :: 55;
    Rgba32Float :: 56;
    Rgba16Float :: 57;
}

BlendFactor :: enum s32 {
    Zero :: 0;
    One :: 1;
    SrcColor :: 2;
    OneMinusSrcColor :: 3;
    DstColor :: 4;
    OneMinusDstColor :: 5;
    SrcAlpha :: 6;
    OneMinusSrcAlpha :: 7;
    DstAlpha :: 8;
    OneMinusDstAlpha :: 9;
    ConstantColor :: 10;
    OneMinusConstantColor :: 11;
    ConstantAlpha :: 12;
    OneMinusConstantAlpha :: 13;
    SrcAlphaSaturate :: 14;
    Src1Color :: 15;
    OneMinusSrc1Color :: 16;
    Src1Alpha :: 17;
    OneMinusSrc1Alpha :: 18;
}

BlendOp :: enum s32 {
    Add :: 0;
    Subtract :: 1;
    ReverseSubtract :: 2;
    Min :: 3;
    Max :: 4;
}

ColorWriteMask :: enum s32 {
    Red :: 1;
    Green :: 2;
    Blue :: 4;
    Alpha :: 8;
    All :: 15;
}

QueryType :: enum s32 {
    Timestamp :: 0;
    Occlusion :: 1;
}

CullMode :: enum s32 {
    None :: 0;
    Back :: 1;
    Front :: 2;
}

DenoiserType :: enum s32 {
    ReblurDiffuse :: 0;
    ReblurDiffuseSpecular :: 1;
    RelaxDiffuse :: 2;
    RelaxDiffuseSpecular :: 3;
    SigmaShadow :: 4;
}

DenoiserResourceId :: enum s32 {
    InViewz :: 0;
    InMv :: 1;
    InNormalRoughness :: 2;
    InDiffRadiance :: 3;
    InSpecRadiance :: 4;
    InShadowData :: 5;
    OutDiffRadiance :: 6;
    OutSpecRadiance :: 7;
    OutShadow :: 8;
    OutValidation :: 9;
    ResourceCount :: 10;
}

StencilOp :: enum s32 {
    Keep :: 0;
    Zero :: 1;
    Replace :: 2;
    IncrementAndClamp :: 3;
    DecrementAndClamp :: 4;
    Invert :: 5;
    IncrementAndWrap :: 6;
    DecrementAndWrap :: 7;
}

CompareOp :: enum s32 {
    Never :: 0;
    Less :: 1;
    Equal :: 2;
    LessEqual :: 3;
    Greater :: 4;
    NotEqual :: 5;
    GreaterEqual :: 6;
    Always :: 7;
}

ShadingRate :: enum s32 {
    _1X1 :: 0;
    _1X2 :: 1;
    _2X1 :: 2;
    _2X2 :: 3;
    _2X4 :: 4;
    _4X2 :: 5;
    _4X4 :: 6;
}

ShadingRateCombiner :: enum s32 {
    Passthrough :: 0;
    Override :: 1;
    Min :: 2;
    Max :: 3;
    Sum :: 4;
}

UpscaleDispatchFlags :: enum_flags s32 {
    None :: 0;
    ResetHistory :: 1;
    UseSpecularMotion :: 2;
}

IndexType :: enum s32 {
    Uint16 :: 0;
    Uint32 :: 1;
}

AccelerationStructureType :: enum s32 {
    TopLevel :: 0;
    BottomLevel :: 1;
}

BuildASFlags :: enum_flags s32 {
    None :: 0;
    PreferFastTrace :: 1;
    PreferFastBuild :: 2;
    AllowUpdate :: 4;
    AllowCompaction :: 8;
}

InstanceFlags :: enum_flags s32 {
    None :: 0;
    TriangleCullDisable :: 1;
    TriangleFlipFacing :: 2;
    ForceOpaque :: 4;
    ForceNonOpaque :: 8;
}

RayTracingPipelineFlags :: enum_flags s32 {
    None :: 0;
    SkipTriangles :: 1;
    SkipAabbs :: 2;
    AllowMicromaps :: 4;
}

ShaderGroupType :: enum s32 {
    General :: 0;
    Triangles :: 1;
    Procedural :: 2;
}

TextureUsageFlags :: enum_flags s32 {
    ShaderResource :: 1;
    RenderTarget :: 2;
    DepthStencil :: 4;
    Storage :: 8;
}

MicromapFormat :: enum s32 {
    _2State :: 1;
    _4State :: 2;
}

BuildMicromapFlags :: enum_flags s32 {
    None :: 0;
    PreferFastTrace :: 1;
    PreferFastBuild :: 2;
    AllowCompaction :: 4;
}

UpscalerType :: enum s32 {
    Nis :: 0;
    Fsr :: 1;
    Xess :: 2;
    Dlsr :: 3;
    Dlrr :: 4;
}

UpscalerMode :: enum s32 {
    Native :: 0;
    UltraQuality :: 1;
    Quality :: 2;
    Balanced :: 3;
    Performance :: 4;
    UltraPerformance :: 5;
}

UpscalerFlags :: enum_flags s32 {
    None :: 0;
    Hdr :: 1;
    Srgb :: 2;
    DepthInverted :: 4;
    DepthInfinite :: 8;
    DepthLinear :: 16;
    MvUpscaled :: 32;
    MvJittered :: 64;
}

Backend :: enum s32 {
    Default :: 0;
    Vulkan :: 1;
    D3D12 :: 2;
    D3D11 :: 3;
    None :: 4;
}

QueueType :: enum s32 {
    Graphics :: 0;
    Compute :: 1;
    Copy :: 2;
}

ResolveOp :: enum s32 {
    Average :: 0;
    Min :: 1;
    Max :: 2;
}

CopyMode :: enum s32 {
    Clone :: 0;
    Compact :: 1;
}

LatencyMarker :: enum s32 {
    SimulationStart :: 0;
    SimulationEnd :: 1;
    RenderSubmitStart :: 2;
    RenderSubmitEnd :: 3;
    InputSample :: 4;
}

MouseButton :: enum s32 {
    Left :: 0;
    Right :: 1;
    Middle :: 2;
}

WindowFlags :: enum_flags s32 {
    Vsync :: 1;
    Fullscreen :: 2;
    Borderless :: 4;
    AlwaysActive :: 8;
    NoResize :: 16;
    Transparent :: 32;
    Floating :: 64;
    Maximized :: 128;
    Hidden :: 256;
    Centered :: 512;
    ScaleToMonitor :: 1024;
}

FeatureSupportFlags :: enum_flags s32 {
    MeshShader :: 1;
    RayTracing :: 2;
    Upscale :: 4;
    LowLatency :: 8;
}

CursorType :: enum s32 {
    Default :: 0;
    Arrow :: 1;
    Ibeam :: 2;
    Crosshair :: 3;
    Hand :: 4;
    ResizeEw :: 5;
    // ResizeH :: 0; // Duplicate
    // ResizeNs :: 1; // Duplicate
    // ResizeV :: 0; // Duplicate
    // ResizeNwse :: 1; // Duplicate
    // ResizeNesw :: 2; // Duplicate
    // ResizeAll :: 3; // Duplicate
    // NotAllowed :: 4; // Duplicate
    // ResizeNw :: 5; // Duplicate
    ResizeN :: 6;
    ResizeNe :: 7;
    ResizeE :: 8;
    ResizeSe :: 9;
    ResizeS :: 10;
    ResizeSw :: 11;
    ResizeW :: 12;
    Wait :: 13;
    Progress :: 14;
    Count :: 15;
}

Key :: enum s32 {
    Space :: 32;
    Apostrophe :: 39;
    Comma :: 44;
    Minus :: 45;
    Period :: 46;
    Slash :: 47;
    _0 :: 48;
    _1 :: 49;
    _2 :: 50;
    _3 :: 51;
    _4 :: 52;
    _5 :: 53;
    _6 :: 54;
    _7 :: 55;
    _8 :: 56;
    _9 :: 57;
    Semicolon :: 59;
    Equal :: 61;
    A :: 65;
    B :: 66;
    C :: 67;
    D :: 68;
    E :: 69;
    F :: 70;
    G :: 71;
    H :: 72;
    I :: 73;
    J :: 74;
    K :: 75;
    L :: 76;
    M :: 77;
    N :: 78;
    O :: 79;
    P :: 80;
    Q :: 81;
    R :: 82;
    S :: 83;
    T :: 84;
    U :: 85;
    V :: 86;
    W :: 87;
    X :: 88;
    Y :: 89;
    Z :: 90;
    LeftBracket :: 91;
    Backslash :: 92;
    RightBracket :: 93;
    GraveAccent :: 96;
    Escape :: 256;
    Enter :: 257;
    Tab :: 258;
    Backspace :: 259;
    Insert :: 260;
    Delete :: 261;
    Right :: 262;
    Left :: 263;
    Down :: 264;
    Up :: 265;
    PageUp :: 266;
    PageDown :: 267;
    Home :: 268;
    End :: 269;
    CapsLock :: 280;
    ScrollLock :: 281;
    NumLock :: 282;
    PrintScreen :: 283;
    Pause :: 284;
    F1 :: 290;
    F2 :: 291;
    F3 :: 292;
    F4 :: 293;
    F5 :: 294;
    F6 :: 295;
    F7 :: 296;
    F8 :: 297;
    F9 :: 298;
    F10 :: 299;
    F11 :: 300;
    F12 :: 301;
    LeftShift :: 340;
    LeftControl :: 341;
    LeftAlt :: 342;
    LeftSuper :: 343;
    RightShift :: 344;
    RightControl :: 345;
    RightAlt :: 346;
    RightSuper :: 347;
    Menu :: 348;
}

// Handles
AccelerationStructure_Impl :: struct {}
AccelerationStructure :: *AccelerationStructure_Impl;
Buffer_Impl :: struct {}
Buffer :: *Buffer_Impl;
CommandList_Impl :: struct {}
CommandList :: *CommandList_Impl;
Denoiser_Impl :: struct {}
Denoiser :: *Denoiser_Impl;
Fence_Impl :: struct {}
Fence :: *Fence_Impl;
Micromap_Impl :: struct {}
Micromap :: *Micromap_Impl;
Pipeline_Impl :: struct {}
Pipeline :: *Pipeline_Impl;
QueryPool_Impl :: struct {}
QueryPool :: *QueryPool_Impl;
Sampler_Impl :: struct {}
Sampler :: *Sampler_Impl;
Shader_Impl :: struct {}
Shader :: *Shader_Impl;
ShaderBindingTable_Impl :: struct {}
ShaderBindingTable :: *ShaderBindingTable_Impl;
Texture_Impl :: struct {}
Texture :: *Texture_Impl;
Upscaler_Impl :: struct {}
Upscaler :: *Upscaler_Impl;

// Structs
AccelerationStructureDesc :: struct {
    type_: AccelerationStructureType;
    flags: BuildASFlags;
    count: u32;
    geometries: *GeometryDesc;
}

AttachmentDesc :: struct {
    format: Format;
    blend: BlendState;
}

BlendState :: struct {
    blend_enabled: bool;
    src_color: BlendFactor;
    dst_color: BlendFactor;
    color_op: BlendOp;
    src_alpha: BlendFactor;
    dst_alpha: BlendFactor;
    alpha_op: BlendOp;
    write_mask: ColorWriteMask;
}

BuildMicromapDesc :: struct {
    dst: Micromap;
    data: Buffer;
    data_offset: u64;
    triangle_indices: Buffer;
    triangle_indices_offset: u64;
    scratch: Buffer;
    scratch_offset: u64;
}

Color :: struct {
    r: float32;
    g: float32;
    b: float32;
    a: float32;
}

ComputePipelineDesc :: struct {
    shader: Shader;
    entry_point: *u8;
}

DenoiserSettings :: struct {
    view_to_clip: [16]float32;
    view_to_clip_prev: [16]float32;
    world_to_view: [16]float32;
    world_to_view_prev: [16]float32;
    denoising_range: float32;
    view_z_scale: float32;
    disocclusion_threshold: float32;
    enable_validation: bool;
    motion_vector_scale: [2]float32;
    is_motion_vector_in_world_space: bool;
    jitter: [2]float32;
    jitter_prev: [2]float32;
    frame_index: u32;
    reset_history: bool;
}

GeometryAABBs :: struct {
    aabb_buffer: Buffer;
    offset: u64;
    count: u32;
    stride: u32;
}

GeometryDesc :: struct {
    is_aabb: bool;
    opaque: bool;
    data: GeometryDesc_Data;
}

GeometryDesc_Data :: union {
    triangles: GeometryTriangles;
    aabbs: GeometryAABBs;
}

GeometryTriangles :: struct {
    vertex_buffer: Buffer;
    vertex_offset: u64;
    vertex_count: u32;
    vertex_stride: u32;
    vertex_format: Format;
    index_buffer: Buffer;
    index_offset: u64;
    index_count: u32;
    index_type: IndexType;
    transform_buffer: Buffer;
    transform_offset: u64;
    micromap: Micromap;
    micromap_index_buffer: Buffer;
    micromap_index_offset: u64;
    micromap_index_type: IndexType;
    micromap_base_triangle: u32;
}

GpuTimestamp :: struct {
    name: *u8;
    microseconds: float32;
}

ImGuiDrawData :: struct {
    draw_lists: *void;
    draw_list_count: u32;
    textures: *void;
    texture_count: u32;
    display_width: float32;
    display_height: float32;
    hdr_scale: float32;
    linear_color: bool;
}

Instance :: struct {
    transform: [3][4]float32;
    instance_id: u32;
    mask: u32;
    instance_contribution_to_hit_group_index: u32;
    flags: InstanceFlags;
    blas: AccelerationStructure;
}

LatencyReport :: struct {
    input_sample_time_us: u64;
    simulation_start_time_us: u64;
    simulation_end_time_us: u64;
    render_submit_start_time_us: u64;
    render_submit_end_time_us: u64;
    present_start_time_us: u64;
    present_end_time_us: u64;
    driver_start_time_us: u64;
    driver_end_time_us: u64;
    os_render_queue_start_time_us: u64;
    os_render_queue_end_time_us: u64;
    gpu_render_start_time_us: u64;
    gpu_render_end_time_us: u64;
}

MicromapDesc :: struct {
    usages: *MicromapUsage;
    usage_count: u32;
    flags: BuildMicromapFlags;
}

MicromapUsage :: struct {
    count: u32;
    subdivision_level: u16;
    format: MicromapFormat;
}

PipelineDesc :: struct {
    shader: Shader;
    color_format: Format;
    blend_state: BlendState;
    attachments: *AttachmentDesc;
    attachment_count: u32;
    depth_format: Format;
    topology: Topology;
    patch_control_points: u32;
    cull_mode: CullMode;
    sample_count: s32;
    depth_test: bool;
    depth_write: bool;
    depth_compare_op: CompareOp;
    depth_bias_constant: float32;
    depth_bias_clamp: float32;
    depth_bias_slope: float32;
    depth_bounds_test: bool;
    stencil: StencilState;
    shading_rate: bool;
    wireframe: bool;
    view_mask: u32;
    vertex_layout: *VertexLayoutElement;
    vertex_layout_count: s32;
    vertex_stride: s32;
    vs_entry_point: *u8;
    ps_entry_point: *u8;
}

RayTracingPipelineDesc :: struct {
    shader: Shader;
    groups: *ShaderGroup;
    group_count: u32;
    max_recursion_depth: u32;
    max_payload_size: u32;
    max_attribute_size: u32;
    flags: RayTracingPipelineFlags;
}

SampleLocation :: struct {
    x: s8;
    y: s8;
}

ShaderGroup :: struct {
    type_: ShaderGroupType;
    general_shader: *u8;
    closest_hit_shader: *u8;
    any_hit_shader: *u8;
    intersection_shader: *u8;
}

StencilFace :: struct {
    compare_op: CompareOp;
    fail_op: StencilOp;
    pass_op: StencilOp;
    depth_fail_op: StencilOp;
}

StencilState :: struct {
    enabled: bool;
    read_mask: u8;
    write_mask: u8;
    front: StencilFace;
    back: StencilFace;
}

TextureDesc :: struct {
    width: u32;
    height: u32;
    depth: u32;
    mip_levels: u32;
    array_layers: u32;
    format: Format;
    sample_count: s32;
    usage: TextureUsageFlags;
    initial_data: *void;
}

TraceRaysDesc :: struct {
    sbt: ShaderBindingTable;
    ray_gen_index: u32;
    miss_index: u32;
    miss_count: u32;
    hit_index: u32;
    hit_count: u32;
    callable_index: u32;
    callable_count: u32;
}

UpscaleDesc :: struct {
    input: Texture;
    output: Texture;
    depth: Texture;
    motion_vectors: Texture;
    exposure: Texture;
    reactive: Texture;
    normal_roughness: Texture;
    diffuse_albedo: Texture;
    specular_albedo: Texture;
    specular_mv_or_hit_t: Texture;
    sss: Texture;
    sharpness: float32;
    jitter: [2]float32;
    motion_vector_scale: [2]float32;
    dispatch_flags: UpscaleDispatchFlags;
    z_near: float32;
    z_far: float32;
    vertical_fov: float32;
    view_space_to_meters_factor: float32;
    view_to_clip: [16]float32;
    world_to_view: [16]float32;
}

UpscalerDesc :: struct {
    type_: UpscalerType;
    mode: UpscalerMode;
    flags: UpscalerFlags;
    output_width: u32;
    output_height: u32;
    preset: u8;
}

UpscalerProps :: struct {
    scaling_factor: float32;
    mip_bias: float32;
    render_width: u32;
    render_height: u32;
    output_width: u32;
    output_height: u32;
    jitter_phase_count: u8;
}

VertexLayoutElement :: struct {
    location: u32;
    format: Format;
    offset: u32;
    semantic_name: *u8;
}

// Functions
request_backend :: (backend: Backend, enable_validation: bool) #foreign librafx "rfxRequestBackend";
open_window :: (title: *u8, width: s32, height: s32) -> bool #foreign librafx "rfxOpenWindow";
supports_features :: (features: FeatureSupportFlags) -> bool #foreign librafx "rfxSupportsFeatures";
get_supported_features :: () -> FeatureSupportFlags #foreign librafx "rfxGetSupportedFeatures";
set_sample_count :: (count: s32) #foreign librafx "rfxSetSampleCount";
set_anisotropy :: (level: s32) #foreign librafx "rfxSetAnisotropy";
set_window_flags :: (flags: WindowFlags) #foreign librafx "rfxSetWindowFlags";
enable_window_flags :: (flags: WindowFlags) #foreign librafx "rfxEnableWindowFlags";
disable_window_flags :: (flags: WindowFlags) #foreign librafx "rfxDisableWindowFlags";
toggle_window_flags :: (flags: WindowFlags) #foreign librafx "rfxToggleWindowFlags";
has_window_flags :: (flags: WindowFlags) -> bool #foreign librafx "rfxHasWindowFlags";
window_should_close :: () -> bool #foreign librafx "rfxWindowShouldClose";
poll_input_events :: () #foreign librafx "rfxPollInputEvents";
get_window_size :: (width: *s32, height: *s32) #foreign librafx "rfxGetWindowSize";
get_window_width :: () -> s32 #foreign librafx "rfxGetWindowWidth";
get_window_height :: () -> s32 #foreign librafx "rfxGetWindowHeight";
get_time :: () -> float64 #foreign librafx "rfxGetTime";
get_delta_time :: () -> float32 #foreign librafx "rfxGetDeltaTime";
get_frame_index :: () -> u32 #foreign librafx "rfxGetFrameIndex";
is_key_down :: (key: Key) -> bool #foreign librafx "rfxIsKeyDown";
is_key_pressed :: (key: Key) -> bool #foreign librafx "rfxIsKeyPressed";
is_key_released :: (key: Key) -> bool #foreign librafx "rfxIsKeyReleased";
is_mouse_button_down :: (button: MouseButton) -> bool #foreign librafx "rfxIsMouseButtonDown";
is_mouse_button_pressed :: (button: MouseButton) -> bool #foreign librafx "rfxIsMouseButtonPressed";
is_mouse_button_released :: (button: MouseButton) -> bool #foreign librafx "rfxIsMouseButtonReleased";
get_mouse_pos :: (x: *float32, y: *float32) #foreign librafx "rfxGetMousePos";
get_mouse_delta :: (x: *float32, y: *float32) #foreign librafx "rfxGetMouseDelta";
set_mouse_cursor_visible :: (visible: bool) #foreign librafx "rfxSetMouseCursorVisible";
set_mouse_cursor :: (cursor: CursorType) #foreign librafx "rfxSetMouseCursor";
create_buffer :: (size: u64, stride: u64, usage: BufferUsageFlags, mem_type: MemoryType, initial_data: *void) -> Buffer #foreign librafx "rfxCreateBuffer";
destroy_buffer :: (buffer: Buffer) #foreign librafx "rfxDestroyBuffer";
map_buffer :: (buffer: Buffer) -> *void #foreign librafx "rfxMapBuffer";
unmap_buffer :: (buffer: Buffer) #foreign librafx "rfxUnmapBuffer";
get_buffer_id :: (buffer: Buffer) -> u32 #foreign librafx "rfxGetBufferId";
create_texture :: (width: s32, height: s32, format: Format, sample_count: s32, usage: TextureUsageFlags, initial_data: *void) -> Texture #foreign librafx "rfxCreateTexture";
create_texture_ex :: (desc: *TextureDesc) -> Texture #foreign librafx "rfxCreateTextureEx";
create_texture_view :: (original: Texture, format: Format, mip: u32, mip_count: u32, layer: u32, layer_count: u32) -> Texture #foreign librafx "rfxCreateTextureView";
destroy_texture :: (texture: Texture) #foreign librafx "rfxDestroyTexture";
get_texture_id :: (texture: Texture) -> u32 #foreign librafx "rfxGetTextureId";
get_texture_descriptor :: (texture: Texture) -> *void #foreign librafx "rfxGetTextureDescriptor";
get_swap_chain_format :: () -> Format #foreign librafx "rfxGetSwapChainFormat";
get_backbuffer_texture :: () -> Texture #foreign librafx "rfxGetBackbufferTexture";
create_sampler :: (filter: Filter, address_mode: AddressMode) -> Sampler #foreign librafx "rfxCreateSampler";
destroy_sampler :: (sampler: Sampler) #foreign librafx "rfxDestroySampler";
compile_shader :: (filepath: *u8, defines: *u8, num_defines: s32, include_dirs: *u8, num_include_dirs: s32) -> Shader #foreign librafx "rfxCompileShader";
compile_shader_mem :: (source: *u8, defines: *u8, num_defines: s32, include_dirs: *u8, num_include_dirs: s32) -> Shader #foreign librafx "rfxCompileShaderMem";
destroy_shader :: (shader: Shader) #foreign librafx "rfxDestroyShader";
watch_shader :: (shader: Shader, watch: bool) #foreign librafx "rfxWatchShader";
create_pipeline :: (desc: *PipelineDesc) -> Pipeline #foreign librafx "rfxCreatePipeline";
destroy_pipeline :: (pipeline: Pipeline) #foreign librafx "rfxDestroyPipeline";
create_compute_pipeline :: (desc: *ComputePipelineDesc) -> Pipeline #foreign librafx "rfxCreateComputePipeline";
set_buffer_name :: (buffer: Buffer, name: *u8) #foreign librafx "rfxSetBufferName";
set_texture_name :: (texture: Texture, name: *u8) #foreign librafx "rfxSetTextureName";
set_pipeline_name :: (pipeline: Pipeline, name: *u8) #foreign librafx "rfxSetPipelineName";
get_command_list :: () -> CommandList #foreign librafx "rfxGetCommandList";
create_command_list :: (queue_type: QueueType) -> CommandList #foreign librafx "rfxCreateCommandList";
destroy_command_list :: (cmd: CommandList) #foreign librafx "rfxDestroyCommandList";
begin_command_list :: (cmd: CommandList) #foreign librafx "rfxBeginCommandList";
end_command_list :: (cmd: CommandList) #foreign librafx "rfxEndCommandList";
begin_frame :: () #foreign librafx "rfxBeginFrame";
end_frame :: () #foreign librafx "rfxEndFrame";
create_fence :: (initial_value: u64) -> Fence #foreign librafx "rfxCreateFence";
destroy_fence :: (fence: Fence) #foreign librafx "rfxDestroyFence";
wait_fence :: (fence: Fence, value: u64) #foreign librafx "rfxWaitFence";
get_fence_value :: (fence: Fence) -> u64 #foreign librafx "rfxGetFenceValue";
submit_command_list_async :: (cmd: CommandList, wait_fences: *Fence, wait_values: *u64, wait_count: u32, signal_fences: *Fence, signal_values: *u64, signal_count: u32) #foreign librafx "rfxSubmitCommandListAsync";
cmd_begin_swapchain_render_pass :: (cmd: CommandList, depth_stencil_format: Format, clear_color: Color) #foreign librafx "rfxCmdBeginSwapchainRenderPass";
cmd_begin_render_pass :: (cmd: CommandList, colors: *Texture, color_count: u32, depth: Texture, clear_color: Color, view_mask: u32) #foreign librafx "rfxCmdBeginRenderPass";
cmd_end_render_pass :: (cmd: CommandList) #foreign librafx "rfxCmdEndRenderPass";
cmd_clear :: (cmd: CommandList, color: Color) #foreign librafx "rfxCmdClear";
cmd_bind_pipeline :: (cmd: CommandList, pipeline: Pipeline) #foreign librafx "rfxCmdBindPipeline";
cmd_set_viewports :: (cmd: CommandList, viewports: *float32, count: u32) #foreign librafx "rfxCmdSetViewports";
cmd_set_scissor :: (cmd: CommandList, x: s32, y: s32, width: s32, height: s32) #foreign librafx "rfxCmdSetScissor";
cmd_set_blend_constants :: (cmd: CommandList, color: Color) #foreign librafx "rfxCmdSetBlendConstants";
cmd_set_stencil_reference :: (cmd: CommandList, front_ref: u8, back_ref: u8) #foreign librafx "rfxCmdSetStencilReference";
cmd_set_depth_bounds :: (cmd: CommandList, min_bound: float32, max_bound: float32) #foreign librafx "rfxCmdSetDepthBounds";
cmd_set_depth_bias :: (cmd: CommandList, constant: float32, clamp: float32, slope: float32) #foreign librafx "rfxCmdSetDepthBias";
cmd_set_shading_rate :: (cmd: CommandList, rate: ShadingRate, primitive_combiner: ShadingRateCombiner, attachment_combiner: ShadingRateCombiner) #foreign librafx "rfxCmdSetShadingRate";
cmd_set_sample_locations :: (cmd: CommandList, locations: *SampleLocation, location_count: u32, sample_count: u32) #foreign librafx "rfxCmdSetSampleLocations";
cmd_bind_vertex_buffer :: (cmd: CommandList, buffer: Buffer) #foreign librafx "rfxCmdBindVertexBuffer";
cmd_bind_index_buffer :: (cmd: CommandList, buffer: Buffer, index_type: IndexType) #foreign librafx "rfxCmdBindIndexBuffer";
cmd_push_constants :: (cmd: CommandList, data: *void, size: u64) #foreign librafx "rfxCmdPushConstants";
cmd_draw :: (cmd: CommandList, vertex_count: u32, instance_count: u32) #foreign librafx "rfxCmdDraw";
cmd_draw_indexed :: (cmd: CommandList, index_count: u32, instance_count: u32) #foreign librafx "rfxCmdDrawIndexed";
cmd_dispatch :: (cmd: CommandList, x: u32, y: u32, z: u32) #foreign librafx "rfxCmdDispatch";
cmd_draw_indirect :: (cmd: CommandList, buffer: Buffer, offset: u64, draw_count: u32, stride: u32) #foreign librafx "rfxCmdDrawIndirect";
cmd_draw_indexed_indirect :: (cmd: CommandList, buffer: Buffer, offset: u64, draw_count: u32, stride: u32) #foreign librafx "rfxCmdDrawIndexedIndirect";
cmd_dispatch_indirect :: (cmd: CommandList, buffer: Buffer, offset: u64) #foreign librafx "rfxCmdDispatchIndirect";
cmd_draw_mesh_tasks :: (cmd: CommandList, x: u32, y: u32, z: u32) #foreign librafx "rfxCmdDrawMeshTasks";
cmd_draw_mesh_tasks_indirect :: (cmd: CommandList, buffer: Buffer, offset: u64, draw_count: u32, stride: u32) #foreign librafx "rfxCmdDrawMeshTasksIndirect";
cmd_draw_indirect_count :: (cmd: CommandList, buffer: Buffer, offset: u64, count_buffer: Buffer, count_buffer_offset: u64, max_draw_count: u32, stride: u32) #foreign librafx "rfxCmdDrawIndirectCount";
cmd_draw_indexed_indirect_count :: (cmd: CommandList, buffer: Buffer, offset: u64, count_buffer: Buffer, count_buffer_offset: u64, max_draw_count: u32, stride: u32) #foreign librafx "rfxCmdDrawIndexedIndirectCount";
cmd_draw_mesh_tasks_indirect_count :: (cmd: CommandList, buffer: Buffer, offset: u64, count_buffer: Buffer, count_buffer_offset: u64, max_draw_count: u32, stride: u32) #foreign librafx "rfxCmdDrawMeshTasksIndirectCount";
cmd_copy_buffer :: (cmd: CommandList, src: Buffer, src_offset: u64, dst: Buffer, dst_offset: u64, size: u64) #foreign librafx "rfxCmdCopyBuffer";
cmd_copy_texture :: (cmd: CommandList, src: Texture, dst: Texture) #foreign librafx "rfxCmdCopyTexture";
cmd_upload_texture :: (cmd: CommandList, dst: Texture, data: *void, mip: u32, layer: u32) #foreign librafx "rfxCmdUploadTexture";
cmd_readback_texture_to_buffer :: (cmd: CommandList, src: Texture, dst: Buffer, dst_offset: u64) #foreign librafx "rfxCmdReadbackTextureToBuffer";
cmd_zero_buffer :: (cmd: CommandList, buffer: Buffer, offset: u64, size: u64) #foreign librafx "rfxCmdZeroBuffer";
cmd_clear_storage_buffer :: (cmd: CommandList, buffer: Buffer, value: u32) #foreign librafx "rfxCmdClearStorageBuffer";
cmd_clear_storage_texture :: (cmd: CommandList, texture: Texture, value: Color) #foreign librafx "rfxCmdClearStorageTexture";
cmd_resolve_texture :: (cmd: CommandList, dst: Texture, src: Texture, op: ResolveOp) #foreign librafx "rfxCmdResolveTexture";
cmd_copy_micromap :: (cmd: CommandList, dst: Micromap, src: Micromap, mode: CopyMode) #foreign librafx "rfxCmdCopyMicromap";
cmd_copy_acceleration_structure :: (cmd: CommandList, dst: AccelerationStructure, src: AccelerationStructure, mode: CopyMode) #foreign librafx "rfxCmdCopyAccelerationStructure";
cmd_transition_buffer :: (cmd: CommandList, buffer: Buffer, state: ResourceState) #foreign librafx "rfxCmdTransitionBuffer";
cmd_transition_texture :: (cmd: CommandList, texture: Texture, state: ResourceState) #foreign librafx "rfxCmdTransitionTexture";
begin_marker :: (name: *u8) #foreign librafx "rfxBeginMarker";
end_marker :: () #foreign librafx "rfxEndMarker";
marker :: (name: *u8) #foreign librafx "rfxMarker";
cmd_begin_event :: (cmd: CommandList, name: *u8) #foreign librafx "rfxCmdBeginEvent";
cmd_end_event :: (cmd: CommandList) #foreign librafx "rfxCmdEndEvent";
cmd_marker :: (cmd: CommandList, name: *u8) #foreign librafx "rfxCmdMarker";
cmd_begin_profile :: (cmd: CommandList, name: *u8) #foreign librafx "rfxCmdBeginProfile";
cmd_end_profile :: (cmd: CommandList) #foreign librafx "rfxCmdEndProfile";
get_gpu_timestamps :: (out_timestamps: *GpuTimestamp, max_count: u32) -> u32 #foreign librafx "rfxGetGpuTimestamps";
create_query_pool :: (type: QueryType, capacity: u32) -> QueryPool #foreign librafx "rfxCreateQueryPool";
destroy_query_pool :: (pool: QueryPool) #foreign librafx "rfxDestroyQueryPool";
cmd_reset_queries :: (cmd: CommandList, pool: QueryPool, offset: u32, count: u32) #foreign librafx "rfxCmdResetQueries";
cmd_begin_query :: (cmd: CommandList, pool: QueryPool, query_index: u32) #foreign librafx "rfxCmdBeginQuery";
cmd_end_query :: (cmd: CommandList, pool: QueryPool, query_index: u32) #foreign librafx "rfxCmdEndQuery";
cmd_copy_queries :: (cmd: CommandList, pool: QueryPool, offset: u32, count: u32, dst_buffer: Buffer, dst_offset: u64) #foreign librafx "rfxCmdCopyQueries";
set_low_latency_mode :: (enabled: bool, boost: bool) #foreign librafx "rfxSetLowLatencyMode";
latency_sleep :: () #foreign librafx "rfxLatencySleep";
set_latency_marker :: (marker: LatencyMarker) #foreign librafx "rfxSetLatencyMarker";
get_latency_report :: (out_report: *LatencyReport) -> bool #foreign librafx "rfxGetLatencyReport";
init_im_gui :: () -> bool #foreign librafx "rfxInitImGui";
shutdown_im_gui :: () #foreign librafx "rfxShutdownImGui";
cmd_draw_im_gui :: (cmd: CommandList, data: *ImGuiDrawData) #foreign librafx "rfxCmdDrawImGui";
create_denoiser :: (type: DenoiserType, width: s32, height: s32) -> Denoiser #foreign librafx "rfxCreateDenoiser";
destroy_denoiser :: (denoiser: Denoiser) #foreign librafx "rfxDestroyDenoiser";
cmd_denoise :: (cmd: CommandList, denoiser: Denoiser, settings: *DenoiserSettings, resources: *Texture, resource_count: u32) #foreign librafx "rfxCmdDenoise";
create_acceleration_structure :: (desc: *AccelerationStructureDesc) -> AccelerationStructure #foreign librafx "rfxCreateAccelerationStructure";
destroy_acceleration_structure :: (as: AccelerationStructure) #foreign librafx "rfxDestroyAccelerationStructure";
get_acceleration_structure_id :: (as: AccelerationStructure) -> u32 #foreign librafx "rfxGetAccelerationStructureId";
get_acceleration_structure_scratch_size :: (as: AccelerationStructure) -> u64 #foreign librafx "rfxGetAccelerationStructureScratchSize";
cmd_write_acceleration_structure_size :: (cmd: CommandList, as_array: *AccelerationStructure, count: u32, pool: QueryPool, query_offset: u32) #foreign librafx "rfxCmdWriteAccelerationStructureSize";
create_ray_tracing_pipeline :: (desc: *RayTracingPipelineDesc) -> Pipeline #foreign librafx "rfxCreateRayTracingPipeline";
create_shader_binding_table :: (pipeline: Pipeline) -> ShaderBindingTable #foreign librafx "rfxCreateShaderBindingTable";
destroy_shader_binding_table :: (sbt: ShaderBindingTable) #foreign librafx "rfxDestroyShaderBindingTable";
cmd_build_acceleration_structure :: (cmd: CommandList, dst: AccelerationStructure, scratch: Buffer, instance_buffer: Buffer) #foreign librafx "rfxCmdBuildAccelerationStructure";
cmd_upload_instances :: (cmd: CommandList, dst_buffer: Buffer, instances: *Instance, instance_count: u32) #foreign librafx "rfxCmdUploadInstances";
cmd_trace_rays :: (cmd: CommandList, desc: *TraceRaysDesc, width: u32, height: u32, depth: u32) #foreign librafx "rfxCmdTraceRays";
cmd_dispatch_rays_indirect :: (cmd: CommandList, args_buffer: Buffer, args_offset: u64) #foreign librafx "rfxCmdDispatchRaysIndirect";
create_micromap :: (desc: *MicromapDesc) -> Micromap #foreign librafx "rfxCreateMicromap";
destroy_micromap :: (micromap: Micromap) #foreign librafx "rfxDestroyMicromap";
get_micromap_scratch_size :: (micromap: Micromap) -> u64 #foreign librafx "rfxGetMicromapScratchSize";
cmd_build_micromaps :: (cmd: CommandList, desc: *BuildMicromapDesc) #foreign librafx "rfxCmdBuildMicromaps";
is_upscaler_supported :: (type: UpscalerType) -> bool #foreign librafx "rfxIsUpscalerSupported";
create_upscaler :: (desc: *UpscalerDesc) -> Upscaler #foreign librafx "rfxCreateUpscaler";
destroy_upscaler :: (upscaler: Upscaler) #foreign librafx "rfxDestroyUpscaler";
get_upscaler_props :: (upscaler: Upscaler, out_props: *UpscalerProps) #foreign librafx "rfxGetUpscalerProps";
cmd_upscale :: (cmd: CommandList, upscaler: Upscaler, desc: *UpscaleDesc) #foreign librafx "rfxCmdUpscale";