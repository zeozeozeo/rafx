import argparse
import os
import subprocess
import sys

import gen_jai
import gen_odin
import gen_rs
from gen_ast import ClangAstParser

GENERATORS = {
    "rust": gen_rs.RustGenerator,
    "odin": gen_odin.OdinGenerator,
    "jai": gen_jai.JaiGenerator,
}


def run_command(cmd, cwd=None):
    try:
        subprocess.run(cmd, check=True, cwd=cwd, capture_output=True, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Error running {' '.join(cmd)}: {e.stderr}")
        return False
    except FileNotFoundError:
        print(f"Error: Command '{cmd[0]}' not found. Is it installed?")
        return False
    return True


def handle_rust_output(output_path, content):
    if not os.path.exists(output_path):
        os.makedirs(output_path)

    if not os.path.exists(os.path.join(output_path, "Cargo.toml")):
        print(f"Initializing new Rust crate in {output_path}...")
        run_command(["cargo", "init", "--lib"], cwd=output_path)
        run_command(["cargo", "add", "bitflags"], cwd=output_path)
        run_command(["cargo", "add", "--build", "cmake"], cwd=output_path)

    lib_path = os.path.join(output_path, "src", "lib.rs")
    with open(lib_path, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"Generated: {lib_path}")

    build_rs_path = os.path.join(output_path, "build.rs")
    rafx_root = "../../"

    with open(build_rs_path, "w", encoding="utf-8") as f:
        f.write(f"""// This file is @generated by Rafx's bindings generator; DO NOT MODIFY
use cmake::Config;

fn main() {{
    let dst = Config::new("{rafx_root}")
        .generator("Ninja")
        .define("RAFX_BUILD_EXAMPLES", "OFF")
        .define("RAFX_D3D12_SUPPORT", "ON")
        .define("CMAKE_MSVC_RUNTIME_LIBRARY", "MultiThreaded$($<$<CONFIG:Debug>:Debug$>)DLL")
        .build();

    println!("cargo:rustc-link-search=native={{}}/build", dst.display());
    println!("cargo:rustc-link-search=native={{}}/build/thirdparty/NRI", dst.display());
    println!("cargo:rustc-link-search=native={{}}/build/thirdparty/NRD", dst.display());
    println!("cargo:rustc-link-search=native={{}}/build/_deps/shadermake-build", dst.display());
    println!("cargo:rustc-link-search=native={{}}/build/_deps/slang-src/lib", dst.display());
    println!("cargo:rustc-link-search=native={{}}/build/_deps/nvapi-src/amd64", dst.display());
    println!("cargo:rustc-link-lib=static=rafx");
    println!("cargo:rustc-link-lib=static=NRI");
    println!("cargo:rustc-link-lib=static=NRI_D3D12");
    println!("cargo:rustc-link-lib=static=NRI_NONE");
    println!("cargo:rustc-link-lib=static=NRI_Shared");
    println!("cargo:rustc-link-lib=static=NRI_Validation");
    println!("cargo:rustc-link-lib=static=NRI_VK");
    println!("cargo:rustc-link-lib=static=NRD");
    println!("cargo:rustc-link-lib=static=ShaderMakeBlob");
    println!("cargo:rustc-link-lib=static=nvapi64");
    println!("cargo:rustc-link-lib=dylib=slang");

    println!("cargo:rustc-link-lib=user32");
    println!("cargo:rustc-link-lib=gdi32");
    println!("cargo:rustc-link-lib=shell32");
    println!("cargo:rustc-link-lib=dxgi");
    println!("cargo:rustc-link-lib=d3d12");
    println!("cargo:rustc-link-lib=dxguid");

    // Ensure we rebuild if the C++ source changes
    println!("cargo:rerun-if-changed={rafx_root}src");
    println!("cargo:rerun-if-changed={rafx_root}include");
}}
""")

    print("Formatting with rustfmt...")
    run_command(["rustfmt", lib_path])


def handle_odin_output(output_path, content):
    if not os.path.exists(output_path):
        os.makedirs(output_path)

    # Main package file
    file_path = os.path.join(output_path, "rafx.odin")
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"Generated: {file_path}")


def handle_jai_output(output_path, content):
    if not os.path.exists(output_path):
        os.makedirs(output_path)

    file_path = os.path.join(output_path, "rafx.jai")
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"Generated: {file_path}")


def main():
    parser = argparse.ArgumentParser(description="FFI Binding Generator")
    parser.add_argument("header", help="Path to the C header file")
    parser.add_argument(
        "-l",
        "--lang",
        choices=GENERATORS.keys(),
        default="rust",
        help="Target language (default: rust)",
    )
    parser.add_argument(
        "-o",
        "--output",
        default="./bindings",
        help="Output directory (for Rust, this is the crate root)",
    )

    args = parser.parse_args()

    if not os.path.exists(args.header):
        print(f"Error: Header file '{args.header}' not found.")
        sys.exit(1)

    print(f"Parsing AST for {args.header}...")
    ast_parser = ClangAstParser(args.header)
    module = ast_parser.parse()

    generator_class = GENERATORS[args.lang]
    generator = generator_class(module)
    generated_code = generator.generate()

    if args.lang == "rust":
        handle_rust_output(args.output, generated_code)
    elif args.lang == "odin":
        handle_odin_output(args.output, generated_code)
    elif args.lang == "jai":
        handle_jai_output(args.output, generated_code)
    else:
        print(generated_code)


if __name__ == "__main__":
    main()
